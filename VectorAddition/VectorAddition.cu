
#include <cuda_runtime.h>
#include <iostream>
#include <device_launch_parameters.h>
#include <random>
#include <string>
#include <chrono>
#include <print>

__global__ void cuda_hello(void)
{
	//int blockid = blockidx.x;
	printf("hello from block: %d, thread: %d\n", blockIdx.x, threadIdx.x);
}

__global__ void addvectors_single_block(int* A, int* B, int* C, int length)
{
	if (threadIdx.x < length)
	{
		C[threadIdx.x] = A[threadIdx.x] + B[threadIdx.x];
	}
}

__global__ void addvectors_multiple_blocks(int* A, int* B, int* C, int length)
{
	if (threadIdx.x < length)
	{
		int index = blockIdx.x * length + threadIdx.x;
		C[index] = A[index] + B[index];
	}
}


int* generate_array(std::string array_name, int size)
{
	int* arr = new int[size];
	

	std::cout << array_name << std::endl;


	//generate random seed for our mersenne twister engine 
	std::random_device rd;
	//pseduo random number gen algorithm 
	std::mt19937 gen(rd());
	//initialize a distrbutor
	//use ditrib to transform the random unsigned int generated by gen into an int in [x to y]
	std::uniform_int_distribution<> distribution(1, 100);

	for (int x = 0; x < size; x++)
	{
		arr[x] = distribution(gen);
		printf("%d ", arr[x]);
	}
	
	std::cout << std::endl;
	
	return arr;
}

void delete_array(int* M)
{
	delete[] M;
	M = nullptr;
}


int main()
{

	int* A = generate_array("arrayA", 20);
	int* B = generate_array("arrayB", 20);
	int* C = new int[20];
	int* D = new int[20];

	//cuda ptr setups
	//these ptrs are for device memory allocations
	int* Z;
	int* Y;
	int* X;
	int* W;

	//cudamalloc
	cudaMalloc(&Z, 20 * 4);
	cudaMalloc(&Y, 20 * 4);
	cudaMalloc(&X, 20 * 4);

	//cudamalloc for our blocks and threads vector add function
	cudaMalloc(&W, 20 * 4);

	//then cuda copy over
	cudaMemcpy(Z, A, 20 * 4, cudaMemcpyHostToDevice);
	cudaMemcpy(Y, B, 20 * 4, cudaMemcpyHostToDevice);

	//perform opp with single block and 20 threads
	auto start1 = std::chrono::high_resolution_clock::now();
	addvectors_single_block << <1, 20>> > (Z, Y, X, 20);
	auto finish1 = std::chrono::high_resolution_clock::now();
	auto microseconds = std::chrono::duration_cast<std::chrono::microseconds>(finish1 - start1);

	//copy back over
	cudaMemcpy(C, X, 20 * 4, cudaMemcpyDeviceToHost);
	printf("\narrayC from 1 block with 20 threads calculated in %d microseconds\n", microseconds);
	for (int x = 0; x < 20; x++)
	{
		printf("%d ", C[x]);
	}
	

	//host code waits until all prev device code (above this line) is done executing
	cudaDeviceSynchronize();
	
	
	//perform opp with 3 block and 20 threads
	start1 = std::chrono::high_resolution_clock::now();
	addvectors_multiple_blocks <<< 3, 20 >> > (Z, Y, W, 20);
	finish1 = std::chrono::high_resolution_clock::now();
	microseconds = std::chrono::duration_cast<std::chrono::microseconds>(finish1 - start1);
	//copy back over
	cudaMemcpy(D, W, 20 * 4, cudaMemcpyDeviceToHost);
	printf("\n\narrayC from 3 blocks with 20 threads each calculated in %d microseconds\n", microseconds);
	for (int x = 0; x < 20; x++)
	{
		printf("%d ", D[x]);
	}
	
	
	//cuda free
	cudaFree(Z);
	cudaFree(Y);
	cudaFree(X);
	cudaFree(W);
	
	cudaDeviceSynchronize();
	
	delete_array(A);
	delete_array(B);
	delete_array(C);
	delete_array(D);
	
	A = nullptr;
	B = nullptr;
	C = nullptr;
	D = nullptr;
	
	return 0;
}